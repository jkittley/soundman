{% load static %}
<html>
    <head>
        <!-- Load c3.css -->
        <link href="{% static "frontend/bootstrap.min.css" %}" rel="stylesheet">
        <link href="{% static "frontend/c3.min.css" %}" rel="stylesheet">
        <!-- Load d3.js and c3.js -->
        <script src="{% static "frontend/d3.v4.min.js" %}" charset="utf-8"></script>
        <script src="{% static "frontend/c3.min.js" %}"></script>
        <script src="{% static "frontend/jquery-3.3.1.min.js" %}"></script>
        <script src="{% static "frontend/bootstrap.min.js" %}"></script>
        <script src="{% static "frontend/moment.js" %}"></script>
    </head>
    <body>
        {% csrf_token %}
        <div class="container-fluid">

            <h1 class="display-4">Latest data</h1>
            <div class="row">
                <div id="plot-space" class="col-md-8"></div>
                <div class="col-md-4">
                    <ul id="data-list" class="list-group"></ul>
                </div>
            </div>
        </div>
    
        <script>
            var plots = {};
            var plotData={};

            var getSensors = function(cb=null) {
                $.getJSON( "/sdstore/sensors/", function( sensors ) {      
                $.each( sensors, function( i, sensor ) {
                    if (cb!==null) cb(sensor);
                });
            });
            }
            
            var getLastReading = function(sensor, channel, cb=null) {
                $.getJSON( "/sdstore/sensor/"+sensor.id+"/"+channel.name+"/last-reading/", function( reading ) {
                    if (cb!==null) {
                        if (reading.hasOwnProperty('timestamp')) cb(reading); else cb(null);
                    }
                });
            }
            
            var getReadings = function(sensor, cb=null) {
                var d = { 
                        csrfmiddlewaretoken : $("[name=csrfmiddlewaretoken]").val(),
                        start: moment().subtract(1, 'h').subtract(10, 'm').format('YYYY-MM-DD HH:mm:ss'),
                        end: moment().subtract(1, 'h').format('YYYY-MM-DD HH:mm:ss'),
                        sensor: sensor.id
                    };
                console.log(d);
                $.ajax({
                    url: "/" ,
                    method: "POST",
                    data: d,
                    dataType: "json",
                }).done(function( readings ) {
                    // console.log(msg);
                    if (cb!==null) cb(readings);
                });
            }

            // List

            var sensorListItemExists = function (sensor) { 
                return $( "#list-"+sensor.id ).length;
            };

            var createSensorListItem = function(sensor) {
                var chlist = $("<ul>").addClass('');
                $('<li>')
                    .prop('id', 'list-'+sensor.id)
                    .addClass('list-group-item')
                    .html('<strong>'+sensor.name+'</strong>').append(chlist)
                    .appendTo( "#data-list" );
            };

            var getSensorListItem = function(sensor) {
                return $("#list-"+sensor.id);
            }

            var channelListItemExists = function (sensor, channel) {
                return $( "#list-"+sensor.id + " .channel_"+channel.id).length;
            };

            var createChannelListItem = function(sensor, channel) {
                $( "<li>")
                    .addClass('channel_'+channel.id)
                    .addClass('row')
                    .append("<div class='col-auto' style='text-transform: capitalize;'>"+channel.name+":</div>")
                    .append("<div class='col-auto ts'></div>")
                    .append("<div class='col-auto val'></div>")
                    .appendTo(getSensorListItem(sensor).find('ul'));                
            }

            var getChannelListItem = function(sensor, channel) {
                return $("#list-"+sensor.id + " .channel_"+channel.id);
            }

            var updateChannelListItem = function(sensor, channel, reading) {
                var channel = getChannelListItem(sensor, channel);
                var elemTs = channel.find('.ts');
                if (elemTs.html() !== reading.timestamp) {
                    channel.find('.val').html(reading.value);
                    elemTs.html(reading.timestamp);
                }
            }

            // Plot

            var sensorPlotExists = function(sensor) {
                return $("#plot-"+sensor.id).length;
            };

            var createSensorPlot = function(sensor) {
                
                $('<div>').addClass("card").addClass("mb-4")
                    .append('<div class="card-header" style="text-transform: capitalize;">'+sensor.name+'</div>')
                    .append('<div class="card-body"><div id="plot-'+sensor.id+'"></div></div>')
                    .appendTo('#plot-space');
                
                plotData[sensor.id] = {
                    json: [],
                    keys: { 
                        x: 'ts',
                        value: [] 
                    },
                    names: {}
                };
                for (i in sensor.channels) {
                    plotData[sensor.id]['keys']['value'].push(sensor.channels[i].name);
                    plotData[sensor.id]['names'][sensor.channels[i].name] = sensor.channels[i].name;
                }
                
                var settings = {
                    bindto: '#plot-'+sensor.id,
                    title: {
                        text: 'Sensor Node' + sensor.id + ' - ' + sensor.name
                    },
                    data: {
                        x: 'ts',
                        xFormat: '%Y-%m-%d %H:%M:%S',
                        json: [],
                        keys: plotData[sensor.id]['keys'],
                        names: plotData[sensor.id]['names']
                    },
                    axis: {
                        x: {
                            type: 'timeseries',
                            tick: {
                                format: '%Y-%m-%d'
                            }
                        }
                    }
                };
                plots[sensor.id] = c3.generate(settings);
                console.log(settings);
            };
            
            var updatePlot = function(sensor, readings) {
                console.log(readings);
                // var mostRecent = plotData[sensor.id]['json'][plotData[sensor.id]['json'].length-1];
                // var add = mostRecent === undefined || mostRecent.ts !== reading.timestamp;
                // var saveData = add ? {} : mostRecent;
                // //
                // saveData['ts'] = reading.timestamp;
                // saveData[channel.id] = reading.value;
                // //
                // console.log(plotData[sensor.id]['json']);
                // if (add) plotData[sensor.id]['json'].push(saveData); 
                // else plotData[sensor.id]['json'][plotData[sensor.id]['json'].length-1] = saveData;
                // //
                plots[sensor.id].load({
                    keys: plotData[sensor.id]['keys'],
                    names: plotData[sensor.id]['names'],
                    json: readings
                });
            }

            // Run
            var main = function() {
                getSensors(function (sensor) {
                    // If the sensor has not been seen before
                    if (!sensorListItemExists(sensor)) createSensorListItem(sensor); 
                    if (!sensorPlotExists(sensor)) createSensorPlot(sensor); 
                    //For each of the sensors channels
                    $.each( sensor.channels, function( j, channel ) {
                        if (!channelListItemExists(sensor, channel)) createChannelListItem(sensor, channel);
                        // Get latest
                        getLastReading(sensor, channel, function(reading) {
                            console.log(reading);
                            updateChannelListItem(sensor, channel, reading);
                            
                        })
                    });
                    // Get readings
                    getReadings(sensor, function(readings) {
                        updatePlot(sensor, readings);
                    });
                    
            });
            }

            main();
            var timer = setInterval(main, 10 * 1000);
        
        </script>
    </body>
</html>
